import re
import pymorphy2

def tokenize_text(text):
    """
    Функция для токенизации текста:
    - преобразует в нижний регистр
    - удаляет все символы, кроме букв кириллицы
    - разделяет на слова
    """
    # Преобразование текста в нижний регистр
    lowercase_text = text.lower()
    
    # Удаление всех символов, кроме букв кириллицы и замена их на пробелы
    cleaned_text = re.sub(r'[^а-яё]', ' ', lowercase_text)
    
    # Разделение на слова и фильтрация пустых слов и слов длиной в 1 символ
    words = [word for word in cleaned_text.split() if len(word) > 1]
    
    return words

# Инициализация морфологического анализатора
morph = pymorphy2.MorphAnalyzer()

# Список стоп-слов (служебные части речи)
stop_words = [
    'в', 'на', 'с', 'по', 'к', 'у', 'о', 'об', 'от', 'из', 'за', 'над', 'под', 'при', 'про', 'для', 'без', 'до', 'через',
    'и', 'или', 'а', 'но', 'да', 'как', 'что', 'если', 'потому', 'чтобы', 'когда', 'хотя', 'пока', 'поскольку',
    'не', 'ни', 'бы', 'ли', 'же', 'только', 'именно', 'даже', 'лишь', 'уже', 'ещё', 'всё', 'всё-таки',
    'это', 'этот', 'эта', 'эти', 'того', 'тот', 'та', 'те', 'такой', 'такая', 'такое', 'такие',
    'весь', 'вся', 'всё', 'все', 'который', 'которая', 'которое', 'которые', 'кто', 'что', 'какой', 'какая', 'какое', 'какие',
    'его', 'её', 'их', 'мой', 'моя', 'моё', 'мои', 'твой', 'твоя', 'твоё', 'твои', 'наш', 'наша', 'наше', 'наши', 'ваш', 'ваша', 'ваше', 'ваши',
    'он', 'она', 'оно', 'они', 'я', 'ты', 'мы', 'вы', 'себя',
    'быть', 'есть', 'был', 'была', 'было', 'были', 'бы',
    'так', 'там', 'тут', 'здесь', 'сюда', 'туда', 'оттуда', 'отсюда',
    'том', 'тому', 'таким', 'чем', 'тем', 
    'иной', 'иное', 'иным', 'иные', 'иному', 'иного'
]

def is_service_part_of_speech(parsed):
    """Проверяет, является ли слово служебной частью речи"""
    service_tags = {'PREP', 'CONJ', 'PRCL', 'INTJ', 'NPRO', 'PRED'}
    return any(tag in parsed.tag.grammemes for tag in service_tags)

def is_same_lexeme(word1, word2):
    """
    Проверяет, являются ли слова формами одного и того же слова (только изменение окончания).
    Слова с приставками считаются разными словами.
    """
    # Получаем разбор обоих слов
    parse1 = morph.parse(word1)[0]
    parse2 = morph.parse(word2)[0]
    
    # Проверяем, что это одно и то же слово в разных формах
    if parse1.normal_form == parse2.normal_form:
        # Сравниваем префиксы (начальные части слов)
        # Если длина префиксов отличается более чем на 2 символа,
        # скорее всего это разные слова с приставками
        min_len = min(len(word1), len(word2))
        common_prefix_len = 0
        for i in range(min_len):
            if word1[i] == word2[i]:
                common_prefix_len += 1
            else:
                break
        
        # Если общий префикс слишком короткий или префиксы сильно различаются по длине,
        # считаем это разными словами
        if common_prefix_len < 3 or abs(len(word1) - len(word2)) > 3:
            return False
            
        return True
    
    return False

def main():
    # Исходные документы
    documents = {
        'document_1': 'В случаях, предусмотренных законом, права, закрепляющие принадлежность объекта гражданских прав определенному лицу, ограничения таких прав и обременения имущества (права на имущество) подлежат государственной регистрации. Государственная регистрация прав на имущество осуществляется уполномоченным в соответствии с законом органом на основе принципов проверки законности оснований регистрации, публичности и достоверности государственного реестра. В государственном реестре должны быть указаны данные, позволяющие определенно установить объект, на который устанавливается право, управомоченное лицо, содержание права, основание его возникновения. Права на имущество, подлежащие государственной регистрации, возникают, изменяются и прекращаются с момента внесения соответствующей записи в государственный реестр, если иное не установлено законом. В случаях, предусмотренных законом или соглашением сторон, сделка, влекущая возникновение, изменение или прекращение прав на имущество, которые подлежат государственной регистрации, должна быть нотариально удостоверена. Запись в государственный реестр вносится при наличии заявлений об этом всех лиц, совершивших сделку, если иное не установлено законом. Если сделка совершена в нотариальной форме, запись в государственный реестр может быть внесена по заявлению любой стороны сделки, в том числе через нотариуса.',
        'document_2': 'Гражданин отвечает по своим обязательствам всем принадлежащим ему имуществом, за исключением имущества, на которое в соответствии с законом не может быть обращено взыскание. Перечень имущества граждан, на которое не может быть обращено взыскание, устанавливается гражданским процессуальным законодательством. В п. 55 указанного Постановления Пленума Верховного Суда РФ разъясняется, что при обращении взыскания на имущество должника - индивидуального предпринимателя по требованиям исполнительного документа, не связанным с осуществлением предпринимательской деятельности, применяются правила очередности, предусмотренные статьей 69 Закона об исполнительном производстве. Вместе с тем при обращении судебным приставом-исполнителем взыскания на имущество должника - индивидуального предпринимателя по требованиям, связанным с его предпринимательской деятельностью (пункт 3 статьи 23 ГК РФ), необходимо соблюдать не только очередность, установленную статьей 69 Закона об исполнительном производстве, но и иные положения законов, определяющих очередность взыскания с учетом такого статуса должника, в частности нормы статьи 94 названного Закона.',
        'document_3': 'Составной частью особого правового режима недвижимого имущества является обязательная государственная регистрация прав на него (перехода прав на него, сделок с ним и обременений недвижимого имущества). Целью такой регистрации является установление прочной системы оборота недвижимости. Мировой опыт убедительно показывает, что для защиты прав частных собственников на недвижимость необходимо создать формальную регистрационную систему, которая гарантировала бы надежность и гласность гражданского оборота, была бы доступна для всех участников гражданских отношений и содержала бы объективную информацию о недвижимости. Государственная регистрация прав на недвижимое имущество и сделок с ним представляет собой элемент публично-правового регулирования в частноправовых отношениях. Однако первое выполняет вторичную роль по отношению к последним. Цель такого регулирования заключается в том, чтобы обеспечить стабильность в гражданских отношениях. Требование об отражении изменений вещно-правового положения участников в Едином государственном реестре прав на недвижимое имущество является реализацией принципа публичности в обороте недвижимости. Слово "государственная" означает, что регистрация должна осуществляться специально уполномоченными федеральными государственными органами. Таким органом в настоящее время является Федеральная служба государственной регистрации, кадастра и картографии (Росреестр).'
    }

    # Объединяем все тексты
    combined_text = ' '.join(documents.values())
    
    # Шаг 1: Токенизируем объединенный текст
    all_words = tokenize_text(combined_text)

    # Шаг 2: Считаем частоту каждого слова
    word_frequency = {}
    for word in all_words:
        if word in word_frequency:
            word_frequency[word] += 1
        else:
            word_frequency[word] = 1

    # Шаг 3: Группируем слова по их леммам
    word_to_lemma = {}
    lemma_to_words = {}
    
    for word in word_frequency:
        # Получаем лемму
        parsed = morph.parse(word)[0]
        lemma = parsed.normal_form
        
        # Пропускаем стоп-слова
        if word in stop_words or lemma in stop_words:
            continue
        
        # Пропускаем служебные части речи
        if is_service_part_of_speech(parsed):
            continue
        
        # Сохраняем связь слово -> лемма
        word_to_lemma[word] = lemma
        
        # Сохраняем связь лемма -> список словоформ
        if lemma not in lemma_to_words:
            lemma_to_words[lemma] = []
        
        if word not in lemma_to_words[lemma]:
            lemma_to_words[lemma].append(word)
    
    # Шаг 4: Считаем частоту каждой леммы (сумма частот её словоформ)
    lemma_frequency = {}
    for word in word_to_lemma:
        lemma = word_to_lemma[word]
        freq = word_frequency.get(word, 0)
        lemma_frequency[lemma] = lemma_frequency.get(lemma, 0) + freq
    
    # Шаг 5: Собираем данные о всех леммах
    lemma_data = {}
    
    for lemma, words in lemma_to_words.items():
        # Подсчитываем общую частоту всех словоформ
        form_count = sum(word_frequency.get(form, 0) for form in words)
        
        # Сохраняем данные о лемме
        lemma_data[lemma] = {
            "forms": words,
            "count": form_count
        }
    
    # Сортируем все леммы по частоте
    all_sorted_lemmas = sorted(lemma_data.items(), key=lambda x: x[1]['count'], reverse=True)
    
    # Выводим результаты для всех слов
    print("Все слова (включая < 3 повторений):")
    for lemma, data in all_sorted_lemmas:
        print(f"{lemma}: {data['count']}")
    
    print("\nСловоформы всех слов:")
    
    for lemma, data in all_sorted_lemmas:
        forms = ", ".join(sorted(data['forms']))
        count = data['count']
        print(f"{lemma}: {forms} - {count} повторений")
    
    # Фильтруем леммы для подсчета итога (частота >= 3)
    frequent_lemmas = [(lemma, data) for lemma, data in all_sorted_lemmas if data['count'] >= 3]
    
    # Выводим только частотные слова
    print("\nНаиболее частотные слова (>= 3 повторений):")
    for lemma, data in frequent_lemmas:
        print(f"{lemma}: {data['count']}")
    
    print("\nСловоформы частотных слов и их количество:")
    
    total_count = 0
    for lemma, data in frequent_lemmas:
        forms = ", ".join(sorted(data['forms']))
        count = data['count']
        print(f"{lemma}: {forms} - {count} повторений")
        total_count += count
    
    print("\nОбщая сумма повторений всех словоформ (только >= 3):", total_count)
    
    return total_count

if __name__ == "__main__":
    # Запуск программы и вывод результата
    result = main()
    print(f"\nРезультат: {result}")